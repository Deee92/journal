## [Test case generation based on execution of mutation traces](https://link.springer.com/article/10.1007/s11219-020-09503-4)

- Automatic test case generation based on potentially absent or outdated models of SUT.
- Test case generation must resort to other artifacts.
- For software maintenance, test cases improved continuously to test adequately for new versions.
- Mutation testing = fault-based testing technique to evaluate the quality of the tests by applying simple changes to the source code and checking if the tests were able to detects those changes
This study
- presents a web testing approach in which test cases generated from user execution traces as a way to deal with the absence of models (**test cases generated through execution traces**)
- applies mutation operators over those test cases to enrich test suite
- designs mutation operators designed to mimic possible real failures
- analyzes additional tests, and keeps those that generate different outcomes because they exercise additional behavior of the web application under test
- Finally illustrates, validates overall approach with case study

### Introduction
- Manual testing often infeasible (time, complexity) => test automation
- Test automation
  - test execution
  - test case generation (usually using models or other artifacts, in this case user execution traces)
  - both
- Mutation testing
  - inject mutations over source code
  - assess quality of test cases (mutation score)
  - guide generation of test cases

User interactions with web app captured and analyzed, subset extracted according to criteria\
Initial set of test cases built, later new test cases generated

_Goal: apply mutation operators over initial set of test cases (not source code) to generate new ones to exercise different aspects of SUT; new test cases added to suite if they enrich test suite quality_

Extension of previous paper
- improves related work section
- presents formalization of mutation operators proposed for TCG
- describes, formalizes criteria to decide if new test case added or discarded
- validates with real website case study

### Related work
- model-based testing: models can describe user actions or events, common for API/GUI testing, mutation operators also applied to models to generate mutant models for TCG
- TCG from existent test suite: mutation operators applied on test cases to enrich test suite, or evolutionary testing through GA
- TCG from random testing and finding crashes
- TCG from user execution traces

### Approach
- TCG using collected info about usage of web application (if model absent)
- GDPR => data inserted by user not captured
- convert to concrete test cases
- modify these using mutation operators to mimic specific problems
- convert test cases to test scripts, execute over web app under test

**Mutation-based test case generation**\
Tool: Ferreira, takes test suite, extends by test case mutation\
Initial test suite collected via JavaScript, collected data saved into Neo4j graph db\
Each test case recorded as a sequence of steps performed by user on web elements (no input values recorded), stored as array of JSON objects, each element => a single step\
Abstract test cases to concrete via random data (numbers, addresses, names) generation (e.g., char pressed to word)\
Script developed to execute each test case by transforming into Java file\
Java file + Selenium => web testing for baseline\
Tool capable of running on Chrome and Firefox, reproducting 5 actions - click, input, drag & drop, back, forward\
Mutation operators applied to generate candidate test cases\
Mutated test cases executed, results compared to baseline\
If different enough, acc to metric, added to test suite

5 possible mutation operators:
- remove step: deletes a user action (step) from execution trace - can be used to ensure mandatory actions not violated
- repeat step: for every two actions in trace, repeats first action with different data - e.g., state - city - change state OR password - confirm password - modified password
- swap step: swaps execution order of two actions in trace - hitting submit before filling form, disabling password and enabling confirm password
- insert empty: inserts empty string - all combinations of empty fields in forms to ensure mandatory input
- add back: adds back action after a button click, followed by another click - check data loss after moving to previous page, then unfilled form - _not very clear_

Candidate test cases generated by applying each of the mutation operators to one of the original concrete test cases

Comparison metrics: check if generated test cases are good enough (different from each other, and baseline test cases) to be part of final test suite; three criteria:
- initial action of execution trace
  - path, action, value, url, position in trace
- result of test case execution
  - result, error, url
- execution traces themselves
  - Levenshtein distance (values 1, 2, 3) to compare sequence of steps within exeution traces
=> two test cases with very similar/identical actions, execution traces, and results discarded (eg filling form fields out of order only gives different results in some particular cases)

**Test case generation tool**: A GUI tool that allows selection of mutation operators to apply, definition of upper limit of mutations to generate, providing a set of test cases\
Tool executes script to run test cases over concrete test cases and candidate test cases\
Generates report listing, signals which test cases were added and which ones discarded

### Case studies
Two case studies:
1. simple user registration website developed to assess if approach works
2. real website - real scenario

**Case study 1: User registration**\
5 mandatory input fields (incl password, confirm password), sign up button, welcome page\
sample (abstract) trace 1: input name, input address, input email, input password, input confirm password, press sign up\
abstract => concrete\
all 5 mutation operators applied => 58 candidates generated (time 1s)\
17 discarted after execution (time 9 min, incl 300 ms delay like humans) acc to criteria\

**Case study 2: Real website**\
public parts of [http://www.ipvc.pt/](http://www.ipvc.pt/)\
user interactions saved in Neo4J db\
total 18,124 user actions, from 11 days of activity\
user actions belong to 4899 sessions (=> 4899 abstract test cases)\
number of generated (candidate) test cases increases almost linearly with size of initial test suite\
10 most frequent paths studied with more than 10 user actions each\
431 mutants/candidate test cases generated\
Levenshtein distance 1 => 66% candidates accepted, 2 and 3 => 6.5%

### Conclusions
user interactions on website (execution trace) => abstract test case => (data generation) => concrete test case => (5 mutation operators) => candidate test cases\
candidate test case runs => acceptance criteria => add to test suite / discard\
Future experiments: more case studies, analysis of quality of final set of test cases acc to metrics like coverage + more web elements (dropdown, checkboxes, radio buttons, links...)\
More mutation operators, including dynamic elements...

